import {
  ANIMATION_DURATION_MS,
  ANIMATION_TIMING_FUNCTION,
  ChartDataProvider,
  ChartsLegend,
  ChartsOverlay,
  ChartsSurface,
  ChartsTooltip,
  ChartsWrapper,
  DEFAULT_X_AXIS_KEY,
  Symbol,
  _extends,
  _objectWithoutPropertiesLoose,
  area_default,
  bumpX,
  bumpY,
  catmullRom_default,
  clampAngle,
  composeClasses,
  deg2rad,
  generateUtilityClass,
  generateUtilityClasses,
  getColor_default,
  getValueToPositionMapper,
  isBandScale,
  line_default,
  linear_default,
  monotoneX,
  monotoneY,
  natural_default,
  require_prop_types,
  selectorChartZoomIsInteracting,
  selectorChartsInteractionXAxisIndex,
  selectorChartsInteractionXAxisValue,
  selectorChartsInteractionYAxisValue,
  stepAfter,
  stepBefore,
  step_default,
  styled_default,
  symbolsFill,
  useAnimateArea,
  useAnimateLine,
  useChartCartesianAxis,
  useChartContainerProps,
  useChartContext,
  useChartGradientIdBuilder,
  useChartHighlight,
  useChartId,
  useChartInteraction,
  useChartZAxis,
  useDrawingArea,
  useEnhancedEffect_default,
  useId,
  useInteractionItemProps,
  useItemHighlighted,
  useItemHighlightedGetter,
  useLineSeriesContext,
  useRtl,
  useSelector,
  useSkipAnimation,
  useSlotProps_default,
  useStore,
  useTheme,
  useThemeProps,
  useXAxes,
  useXScale,
  useYAxes,
  useYScale,
  warnOnce
} from "./chunk-XLILH43K.js";
import {
  require_jsx_runtime
} from "./chunk-JNNNAK6O.js";
import "./chunk-A7ECLLTJ.js";
import {
  require_react
} from "./chunk-HSUUC2QV.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/@mui/x-charts/esm/LineChart/LineChart.js
var React29 = __toESM(require_react(), 1);
var import_prop_types19 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/AreaPlot.js
var React4 = __toESM(require_react(), 1);
var import_prop_types3 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/AreaElement.js
var React3 = __toESM(require_react(), 1);
var import_prop_types2 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/AnimatedArea.js
var React2 = __toESM(require_react(), 1);
var import_prop_types = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/AppearingMask.js
var React = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/cleanId.js
function cleanId(id) {
  return id.replace(" ", "_");
}

// node_modules/@mui/x-charts/esm/LineChart/AppearingMask.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var appearingMaskClasses = generateUtilityClasses("MuiAppearingMask", ["animate"]);
var AnimatedRect = styled_default("rect")({
  animationName: "animate-width",
  animationTimingFunction: ANIMATION_TIMING_FUNCTION,
  animationDuration: "0s",
  [`&.${appearingMaskClasses.animate}`]: {
    animationDuration: `${ANIMATION_DURATION_MS}ms`
  },
  "@keyframes animate-width": {
    from: {
      width: 0
    }
  }
});
function AppearingMask(props) {
  const drawingArea = useDrawingArea();
  const chartId = useChartId();
  const clipId = cleanId(`${chartId}-${props.id}`);
  return (0, import_jsx_runtime.jsxs)(React.Fragment, {
    children: [(0, import_jsx_runtime.jsx)("clipPath", {
      id: clipId,
      children: (0, import_jsx_runtime.jsx)(AnimatedRect, {
        className: props.skipAnimation ? "" : appearingMaskClasses.animate,
        x: 0,
        y: 0,
        width: drawingArea.left + drawingArea.width + drawingArea.right,
        height: drawingArea.top + drawingArea.height + drawingArea.bottom
      })
    }), (0, import_jsx_runtime.jsx)("g", {
      clipPath: `url(#${clipId})`,
      children: props.children
    })]
  });
}

// node_modules/@mui/x-charts/esm/LineChart/AnimatedArea.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var _excluded = ["skipAnimation", "ownerState"];
function AnimatedArea(props) {
  const {
    skipAnimation,
    ownerState
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const animatedProps = useAnimateArea(props);
  return (0, import_jsx_runtime2.jsx)(AppearingMask, {
    skipAnimation,
    id: `${ownerState.id}-area-clip`,
    children: (0, import_jsx_runtime2.jsx)("path", _extends({
      fill: ownerState.gradientId ? `url(#${ownerState.gradientId})` : ownerState.color,
      filter: (
        // eslint-disable-next-line no-nested-ternary
        ownerState.isHighlighted ? "brightness(140%)" : ownerState.gradientId ? void 0 : "brightness(120%)"
      ),
      opacity: ownerState.isFaded ? 0.3 : 1,
      stroke: "none"
    }, other, animatedProps))
  });
}
true ? AnimatedArea.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  d: import_prop_types.default.string.isRequired,
  ownerState: import_prop_types.default.shape({
    classes: import_prop_types.default.object,
    color: import_prop_types.default.string.isRequired,
    gradientId: import_prop_types.default.string,
    id: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]).isRequired,
    isFaded: import_prop_types.default.bool.isRequired,
    isHighlighted: import_prop_types.default.bool.isRequired
  }).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types.default.bool
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/AreaElement.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var _excluded2 = ["id", "classes", "color", "gradientId", "slots", "slotProps", "onClick"];
function getAreaElementUtilityClass(slot) {
  return generateUtilityClass("MuiAreaElement", slot);
}
var areaElementClasses = generateUtilityClasses("MuiAreaElement", ["root", "highlighted", "faded", "series"]);
var useUtilityClasses = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getAreaElementUtilityClass, classes);
};
function AreaElement(props) {
  const {
    id,
    classes: innerClasses,
    color,
    gradientId,
    slots,
    slotProps,
    onClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  const interactionProps = useInteractionItemProps({
    type: "line",
    seriesId: id
  });
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id
  });
  const ownerState = {
    id,
    classes: innerClasses,
    color,
    gradientId,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses(ownerState);
  const Area = (slots == null ? void 0 : slots.area) ?? AnimatedArea;
  const areaProps = useSlotProps_default({
    elementType: Area,
    externalSlotProps: slotProps == null ? void 0 : slotProps.area,
    additionalProps: _extends({}, interactionProps, {
      onClick,
      cursor: onClick ? "pointer" : "unset"
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime3.jsx)(Area, _extends({}, other, areaProps));
}
true ? AreaElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types2.default.object,
  color: import_prop_types2.default.string.isRequired,
  d: import_prop_types2.default.string.isRequired,
  gradientId: import_prop_types2.default.string,
  id: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types2.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types2.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types2.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/internals/getCurve.js
function getCurveFactory(curveType) {
  switch (curveType) {
    case "catmullRom":
      return catmullRom_default.alpha(0.5);
    case "linear":
      return linear_default;
    case "monotoneX":
      return monotoneX;
    case "monotoneY":
      return monotoneY;
    case "natural":
      return natural_default;
    case "step":
      return step_default;
    case "stepBefore":
      return stepBefore;
    case "stepAfter":
      return stepAfter;
    case "bumpY":
      return bumpY;
    case "bumpX":
      return bumpX;
    default:
      return monotoneX;
  }
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartCartesianAxis/useInternalIsZoomInteracting.js
function useInternalIsZoomInteracting() {
  const store = useStore();
  const isInteracting = useSelector(store, selectorChartZoomIsInteracting);
  return isInteracting;
}

// node_modules/@mui/x-charts/esm/LineChart/AreaPlot.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var _excluded3 = ["slots", "slotProps", "onItemClick", "skipAnimation"];
var AreaPlotRoot = styled_default("g", {
  name: "MuiAreaPlot",
  slot: "Root"
})({
  [`& .${areaElementClasses.root}`]: {
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in"
  }
});
var useAggregatedData = () => {
  const seriesData = useLineSeriesContext();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const getGradientId = useChartGradientIdBuilder();
  const allData = React4.useMemo(() => {
    if (seriesData === void 0) {
      return [];
    }
    const {
      series,
      stackingGroups
    } = seriesData;
    const defaultXAxisId = xAxisIds[0];
    const defaultYAxisId = yAxisIds[0];
    return stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return [...groupIds].reverse().map((seriesId) => {
        const {
          xAxisId = defaultXAxisId,
          yAxisId = defaultYAxisId,
          stackedData,
          data,
          connectNulls,
          baseline,
          curve,
          strictStepCurve
        } = series[seriesId];
        const xScale = xAxis[xAxisId].scale;
        const xPosition = getValueToPositionMapper(xScale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        const gradientId = yAxis[yAxisId].colorScale && getGradientId(yAxisId) || xAxis[xAxisId].colorScale && getGradientId(xAxisId) || void 0;
        if (true) {
          if (xData === void 0) {
            throw new Error(`MUI X Charts: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
          }
          if (xData.length < stackedData.length) {
            throw new Error(`MUI X Charts: The data length of the x axis (${xData.length} items) is lower than the length of series (${stackedData.length} items).`);
          }
        }
        const shouldExpand = (curve == null ? void 0 : curve.includes("step")) && !strictStepCurve && isBandScale(xScale);
        const formattedData = (xData == null ? void 0 : xData.flatMap((x, index) => {
          const nullData = data[index] == null;
          if (shouldExpand) {
            const rep = [{
              x,
              y: stackedData[index],
              nullData,
              isExtension: false
            }];
            if (!nullData && (index === 0 || data[index - 1] == null)) {
              rep.unshift({
                x: (xScale(x) ?? 0) - (xScale.step() - xScale.bandwidth()) / 2,
                y: stackedData[index],
                nullData,
                isExtension: true
              });
            }
            if (!nullData && (index === data.length - 1 || data[index + 1] == null)) {
              rep.push({
                x: (xScale(x) ?? 0) + (xScale.step() + xScale.bandwidth()) / 2,
                y: stackedData[index],
                nullData,
                isExtension: true
              });
            }
            return rep;
          }
          return {
            x,
            y: stackedData[index],
            nullData
          };
        })) ?? [];
        const d3Data = connectNulls ? formattedData.filter((d2) => !d2.nullData) : formattedData;
        const areaPath = area_default().x((d2) => d2.isExtension ? d2.x : xPosition(d2.x)).defined((d2) => connectNulls || !d2.nullData || !!d2.isExtension).y0((d2) => {
          if (typeof baseline === "number") {
            return yScale(baseline);
          }
          if (baseline === "max") {
            return yScale.range()[1];
          }
          if (baseline === "min") {
            return yScale.range()[0];
          }
          const value = d2.y && yScale(d2.y[0]);
          if (Number.isNaN(value)) {
            return yScale.range()[0];
          }
          return value;
        }).y1((d2) => d2.y && yScale(d2.y[1]));
        const d = areaPath.curve(getCurveFactory(curve))(d3Data) || "";
        return _extends({}, series[seriesId], {
          gradientId,
          d,
          seriesId
        });
      });
    });
  }, [seriesData, xAxisIds, yAxisIds, xAxis, yAxis, getGradientId]);
  return allData;
};
function AreaPlot(props) {
  const {
    slots,
    slotProps,
    onItemClick,
    skipAnimation: inSkipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded3);
  const isZoomInteracting = useInternalIsZoomInteracting();
  const skipAnimation = useSkipAnimation(isZoomInteracting || inSkipAnimation);
  const completedData = useAggregatedData();
  return (0, import_jsx_runtime4.jsx)(AreaPlotRoot, _extends({}, other, {
    children: completedData.map(({
      d,
      seriesId,
      color,
      area,
      gradientId
    }) => !!area && (0, import_jsx_runtime4.jsx)(AreaElement, {
      id: seriesId,
      d,
      color,
      gradientId,
      slots,
      slotProps,
      onClick: onItemClick && ((event) => onItemClick(event, {
        type: "line",
        seriesId
      })),
      skipAnimation
    }, seriesId))
  }));
}
true ? AreaPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line area item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line item identifier.
   */
  onItemClick: import_prop_types3.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types3.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types3.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types3.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/LinePlot.js
var React7 = __toESM(require_react(), 1);
var import_prop_types6 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/LineElement.js
var React6 = __toESM(require_react(), 1);
var import_prop_types5 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/AnimatedLine.js
var React5 = __toESM(require_react(), 1);
var import_prop_types4 = __toESM(require_prop_types(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var _excluded4 = ["skipAnimation", "ownerState"];
var AnimatedLine = React5.forwardRef(function AnimatedLine2(props, ref) {
  const {
    skipAnimation,
    ownerState
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
  const animateProps = useAnimateLine(_extends({}, props, {
    ref
  }));
  return (0, import_jsx_runtime5.jsx)(AppearingMask, {
    skipAnimation,
    id: `${ownerState.id}-line-clip`,
    children: (0, import_jsx_runtime5.jsx)("path", _extends({
      stroke: ownerState.gradientId ? `url(#${ownerState.gradientId})` : ownerState.color,
      strokeWidth: 2,
      strokeLinejoin: "round",
      fill: "none",
      filter: ownerState.isHighlighted ? "brightness(120%)" : void 0,
      opacity: ownerState.isFaded ? 0.3 : 1
    }, other, animateProps))
  });
});
if (true) AnimatedLine.displayName = "AnimatedLine";
true ? AnimatedLine.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  d: import_prop_types4.default.string.isRequired,
  ownerState: import_prop_types4.default.shape({
    classes: import_prop_types4.default.object,
    color: import_prop_types4.default.string.isRequired,
    gradientId: import_prop_types4.default.string,
    id: import_prop_types4.default.oneOfType([import_prop_types4.default.number, import_prop_types4.default.string]).isRequired,
    isFaded: import_prop_types4.default.bool.isRequired,
    isHighlighted: import_prop_types4.default.bool.isRequired
  }).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types4.default.bool
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/LineElement.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var _excluded5 = ["id", "classes", "color", "gradientId", "slots", "slotProps", "onClick"];
function getLineElementUtilityClass(slot) {
  return generateUtilityClass("MuiLineElement", slot);
}
var lineElementClasses = generateUtilityClasses("MuiLineElement", ["root", "highlighted", "faded", "series"]);
var useUtilityClasses2 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getLineElementUtilityClass, classes);
};
function LineElement(props) {
  const {
    id,
    classes: innerClasses,
    color,
    gradientId,
    slots,
    slotProps,
    onClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  const interactionProps = useInteractionItemProps({
    type: "line",
    seriesId: id
  });
  const {
    isFaded,
    isHighlighted
  } = useItemHighlighted({
    seriesId: id
  });
  const ownerState = {
    id,
    classes: innerClasses,
    color,
    gradientId,
    isFaded,
    isHighlighted
  };
  const classes = useUtilityClasses2(ownerState);
  const Line = (slots == null ? void 0 : slots.line) ?? AnimatedLine;
  const lineProps = useSlotProps_default({
    elementType: Line,
    externalSlotProps: slotProps == null ? void 0 : slotProps.line,
    additionalProps: _extends({}, interactionProps, {
      onClick,
      cursor: onClick ? "pointer" : "unset"
    }),
    className: classes.root,
    ownerState
  });
  return (0, import_jsx_runtime6.jsx)(Line, _extends({}, other, lineProps));
}
true ? LineElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types5.default.object,
  color: import_prop_types5.default.string.isRequired,
  d: import_prop_types5.default.string.isRequired,
  gradientId: import_prop_types5.default.string,
  id: import_prop_types5.default.oneOfType([import_prop_types5.default.number, import_prop_types5.default.string]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types5.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types5.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types5.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/LinePlot.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var _excluded6 = ["slots", "slotProps", "skipAnimation", "onItemClick"];
var LinePlotRoot = styled_default("g", {
  name: "MuiAreaPlot",
  slot: "Root"
})({
  [`& .${lineElementClasses.root}`]: {
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in"
  }
});
var useAggregatedData2 = () => {
  const seriesData = useLineSeriesContext();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const getGradientId = useChartGradientIdBuilder();
  const allData = React7.useMemo(() => {
    if (seriesData === void 0) {
      return [];
    }
    const {
      series,
      stackingGroups
    } = seriesData;
    const defaultXAxisId = xAxisIds[0];
    const defaultYAxisId = yAxisIds[0];
    return stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return groupIds.flatMap((seriesId) => {
        const {
          xAxisId = defaultXAxisId,
          yAxisId = defaultYAxisId,
          stackedData,
          data,
          connectNulls,
          curve,
          strictStepCurve
        } = series[seriesId];
        const xScale = xAxis[xAxisId].scale;
        const xPosition = getValueToPositionMapper(xScale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        const gradientId = yAxis[yAxisId].colorScale && getGradientId(yAxisId) || xAxis[xAxisId].colorScale && getGradientId(xAxisId) || void 0;
        if (true) {
          if (xData === void 0) {
            throw new Error(`MUI X Charts: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
          }
          if (xData.length < stackedData.length) {
            warnOnce(`MUI X Charts: The data length of the x axis (${xData.length} items) is lower than the length of series (${stackedData.length} items).`, "error");
          }
        }
        const shouldExpand = (curve == null ? void 0 : curve.includes("step")) && !strictStepCurve && isBandScale(xScale);
        const formattedData = (xData == null ? void 0 : xData.flatMap((x, index) => {
          const nullData = data[index] == null;
          if (shouldExpand) {
            const rep = [{
              x,
              y: stackedData[index],
              nullData,
              isExtension: false
            }];
            if (!nullData && (index === 0 || data[index - 1] == null)) {
              rep.unshift({
                x: (xScale(x) ?? 0) - (xScale.step() - xScale.bandwidth()) / 2,
                y: stackedData[index],
                nullData,
                isExtension: true
              });
            }
            if (!nullData && (index === data.length - 1 || data[index + 1] == null)) {
              rep.push({
                x: (xScale(x) ?? 0) + (xScale.step() + xScale.bandwidth()) / 2,
                y: stackedData[index],
                nullData,
                isExtension: true
              });
            }
            return rep;
          }
          return {
            x,
            y: stackedData[index],
            nullData
          };
        })) ?? [];
        const d3Data = connectNulls ? formattedData.filter((d2) => !d2.nullData) : formattedData;
        const linePath = line_default().x((d2) => d2.isExtension ? d2.x : xPosition(d2.x)).defined((d2) => connectNulls || !d2.nullData || !!d2.isExtension).y((d2) => yScale(d2.y[1]));
        const d = linePath.curve(getCurveFactory(curve))(d3Data) || "";
        return _extends({}, series[seriesId], {
          gradientId,
          d,
          seriesId
        });
      });
    });
  }, [seriesData, xAxisIds, yAxisIds, xAxis, yAxis, getGradientId]);
  return allData;
};
function LinePlot(props) {
  const {
    slots,
    slotProps,
    skipAnimation: inSkipAnimation,
    onItemClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
  const isZoomInteracting = useInternalIsZoomInteracting();
  const skipAnimation = useSkipAnimation(isZoomInteracting || inSkipAnimation);
  const completedData = useAggregatedData2();
  return (0, import_jsx_runtime7.jsx)(LinePlotRoot, _extends({}, other, {
    children: completedData.map(({
      d,
      seriesId,
      color,
      gradientId
    }) => {
      return (0, import_jsx_runtime7.jsx)(LineElement, {
        id: seriesId,
        d,
        color,
        gradientId,
        skipAnimation,
        slots,
        slotProps,
        onClick: onItemClick && ((event) => onItemClick(event, {
          type: "line",
          seriesId
        }))
      }, seriesId);
    })
  }));
}
true ? LinePlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line item identifier.
   */
  onItemClick: import_prop_types6.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types6.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types6.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types6.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/MarkPlot.js
var import_prop_types9 = __toESM(require_prop_types(), 1);
var React10 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/LineChart/CircleMarkElement.js
var React8 = __toESM(require_react(), 1);
var import_prop_types7 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/markElementClasses.js
function getMarkElementUtilityClass(slot) {
  return generateUtilityClass("MuiMarkElement", slot);
}
var markElementClasses = generateUtilityClasses("MuiMarkElement", ["root", "highlighted", "faded", "animate", "series"]);
var useUtilityClasses3 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted,
    skipAnimation
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded", skipAnimation ? void 0 : "animate"]
  };
  return composeClasses(slots, getMarkElementUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/LineChart/CircleMarkElement.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var _excluded7 = ["x", "y", "id", "classes", "color", "dataIndex", "onClick", "skipAnimation", "isFaded", "isHighlighted"];
var Circle = styled_default("circle")({
  [`&.${markElementClasses.animate}`]: {
    transitionDuration: `${ANIMATION_DURATION_MS}ms`,
    transitionProperty: "cx, cy",
    transitionTimingFunction: ANIMATION_TIMING_FUNCTION
  }
});
function CircleMarkElement(props) {
  const {
    x,
    y,
    id,
    classes: innerClasses,
    color,
    dataIndex,
    onClick,
    skipAnimation,
    isFaded = false,
    isHighlighted = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded7);
  const theme = useTheme();
  const interactionProps = useInteractionItemProps({
    type: "line",
    seriesId: id,
    dataIndex
  });
  const ownerState = {
    id,
    classes: innerClasses,
    isHighlighted,
    isFaded,
    color,
    skipAnimation
  };
  const classes = useUtilityClasses3(ownerState);
  return (0, import_jsx_runtime8.jsx)(Circle, _extends({}, other, {
    cx: x,
    cy: y,
    r: 5,
    fill: (theme.vars || theme).palette.background.paper,
    stroke: color,
    strokeWidth: 2,
    className: classes.root,
    onClick,
    cursor: onClick ? "pointer" : "unset"
  }, interactionProps));
}
true ? CircleMarkElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types7.default.object,
  /**
   * The index to the element in the series' data array.
   */
  dataIndex: import_prop_types7.default.number.isRequired,
  id: import_prop_types7.default.oneOfType([import_prop_types7.default.number, import_prop_types7.default.string]).isRequired,
  /**
   * The shape of the marker.
   */
  shape: import_prop_types7.default.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types7.default.bool
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/MarkElement.js
var React9 = __toESM(require_react(), 1);
var import_prop_types8 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/internals/getSymbol.js
function getSymbol(shape) {
  switch (shape) {
    case "circle":
      return 0;
    case "cross":
      return 1;
    case "diamond":
      return 2;
    case "square":
      return 3;
    case "star":
      return 4;
    case "triangle":
      return 5;
    case "wye":
      return 6;
    default:
      return 0;
  }
}

// node_modules/@mui/x-charts/esm/LineChart/MarkElement.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var _excluded8 = ["x", "y", "id", "classes", "color", "shape", "dataIndex", "onClick", "skipAnimation", "isFaded", "isHighlighted"];
var MarkElementPath = styled_default("path", {
  name: "MuiMarkElement",
  slot: "Root"
})(({
  ownerState,
  theme
}) => ({
  fill: (theme.vars || theme).palette.background.paper,
  stroke: ownerState.color,
  strokeWidth: 2,
  [`&.${markElementClasses.animate}`]: {
    transitionDuration: `${ANIMATION_DURATION_MS}ms`,
    transitionProperty: "transform, transform-origin",
    transitionTimingFunction: ANIMATION_TIMING_FUNCTION
  }
}));
function MarkElement(props) {
  const {
    x,
    y,
    id,
    classes: innerClasses,
    color,
    shape,
    dataIndex,
    onClick,
    skipAnimation,
    isFaded = false,
    isHighlighted = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded8);
  const interactionProps = useInteractionItemProps({
    type: "line",
    seriesId: id,
    dataIndex
  });
  const ownerState = {
    id,
    classes: innerClasses,
    isHighlighted,
    isFaded,
    color,
    skipAnimation
  };
  const classes = useUtilityClasses3(ownerState);
  return (0, import_jsx_runtime9.jsx)(MarkElementPath, _extends({}, other, {
    style: {
      transform: `translate(${x}px, ${y}px)`,
      transformOrigin: `${x}px ${y}px`
    },
    ownerState,
    className: classes.root,
    d: Symbol(symbolsFill[getSymbol(shape)])(),
    onClick,
    cursor: onClick ? "pointer" : "unset"
  }, interactionProps));
}
true ? MarkElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types8.default.object,
  /**
   * The index to the element in the series' data array.
   */
  dataIndex: import_prop_types8.default.number.isRequired,
  id: import_prop_types8.default.oneOfType([import_prop_types8.default.number, import_prop_types8.default.string]).isRequired,
  /**
   * If `true`, the marker is faded.
   * @default false
   */
  isFaded: import_prop_types8.default.bool,
  /**
   * If `true`, the marker is highlighted.
   * @default false
   */
  isHighlighted: import_prop_types8.default.bool,
  /**
   * The shape of the marker.
   */
  shape: import_prop_types8.default.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired,
  /**
   * If `true`, animations are skipped.
   */
  skipAnimation: import_prop_types8.default.bool
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/MarkPlot.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var _excluded9 = ["slots", "slotProps", "skipAnimation", "onItemClick"];
function MarkPlot(props) {
  const {
    slots,
    slotProps,
    skipAnimation: inSkipAnimation,
    onItemClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded9);
  const isZoomInteracting = useInternalIsZoomInteracting();
  const skipAnimation = useSkipAnimation(isZoomInteracting || inSkipAnimation);
  const seriesData = useLineSeriesContext();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const chartId = useChartId();
  const {
    instance,
    store
  } = useChartContext();
  const {
    isFaded,
    isHighlighted
  } = useItemHighlightedGetter();
  const xAxisInteractionIndex = useSelector(store, selectorChartsInteractionXAxisIndex);
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    stackingGroups
  } = seriesData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  return (0, import_jsx_runtime10.jsx)("g", _extends({}, other, {
    children: stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return groupIds.map((seriesId) => {
        const {
          xAxisId = defaultXAxisId,
          yAxisId = defaultYAxisId,
          stackedData,
          data,
          showMark = true,
          shape = "circle"
        } = series[seriesId];
        if (showMark === false) {
          return null;
        }
        const xScale = getValueToPositionMapper(xAxis[xAxisId].scale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        if (xData === void 0) {
          throw new Error(`MUI X Charts: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
        }
        const clipId = cleanId(`${chartId}-${seriesId}-line-clip`);
        const colorGetter = getColor_default(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
        const Mark = (slots == null ? void 0 : slots.mark) ?? (shape === "circle" ? CircleMarkElement : MarkElement);
        const isSeriesHighlighted = isHighlighted({
          seriesId
        });
        const isSeriesFaded = !isSeriesHighlighted && isFaded({
          seriesId
        });
        return (0, import_jsx_runtime10.jsx)("g", {
          clipPath: `url(#${clipId})`,
          children: xData == null ? void 0 : xData.map((x, index) => {
            const value = data[index] == null ? null : stackedData[index][1];
            return {
              x: xScale(x),
              y: value === null ? null : yScale(value),
              position: x,
              value,
              index
            };
          }).filter(({
            x,
            y,
            index,
            position,
            value
          }) => {
            if (value === null || y === null) {
              return false;
            }
            if (!instance.isPointInside(x, y)) {
              return false;
            }
            if (showMark === true) {
              return true;
            }
            return showMark({
              x,
              y,
              index,
              position,
              value
            });
          }).map(({
            x,
            y,
            index
          }) => {
            return (0, import_jsx_runtime10.jsx)(Mark, _extends({
              id: seriesId,
              dataIndex: index,
              shape,
              color: colorGetter(index),
              x,
              y,
              skipAnimation,
              onClick: onItemClick && ((event) => onItemClick(event, {
                type: "line",
                seriesId,
                dataIndex: index
              })),
              isHighlighted: xAxisInteractionIndex === index || isSeriesHighlighted,
              isFaded: isSeriesFaded
            }, slotProps == null ? void 0 : slotProps.mark), `${seriesId}-${index}`);
          })
        }, seriesId);
      });
    })
  }));
}
true ? MarkPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line mark item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line mark item identifier.
   */
  onItemClick: import_prop_types9.default.func,
  /**
   * If `true`, animations are skipped.
   */
  skipAnimation: import_prop_types9.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types9.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types9.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxis/ChartsAxis.js
var React17 = __toESM(require_react(), 1);
var import_prop_types13 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsXAxis.js
var React15 = __toESM(require_react(), 1);
var import_prop_types11 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/hooks/useIsHydrated.js
var React11 = __toESM(require_react(), 1);
function useIsHydrated() {
  const [isHydrated, setIsHydrated] = React11.useState(typeof window !== "undefined" || false);
  React11.useEffect(() => {
    setIsHydrated(true);
  }, []);
  return isHydrated;
}

// node_modules/@mui/x-charts/esm/internals/getGraphemeCount.js
var segmenter = typeof window !== "undefined" && "Intl" in window && "Segmenter" in Intl ? new Intl.Segmenter(void 0, {
  granularity: "grapheme"
}) : null;
function getGraphemeCountFallback(text) {
  return text.length;
}
function getGraphemeCountModern(text) {
  const segments = segmenter.segment(text);
  let count = 0;
  for (const _unused of segments) {
    count += 1;
  }
  return count;
}
var getGraphemeCount = segmenter ? getGraphemeCountModern : getGraphemeCountFallback;

// node_modules/@mui/x-charts/esm/internals/degToRad.js
function degToRad(degrees) {
  return degrees * (Math.PI / 180);
}

// node_modules/@mui/x-charts/esm/internals/sliceUntil.js
var segmenter2 = typeof window !== "undefined" && "Intl" in window && "Segmenter" in Intl ? new Intl.Segmenter(void 0, {
  granularity: "grapheme"
}) : null;
function sliceUntilFallback(text, endIndex) {
  return text.slice(0, endIndex);
}
function sliceUntilModern(text, endIndex) {
  const segments = segmenter2.segment(text);
  let newText = "";
  let i = 0;
  for (const segment of segments) {
    newText += segment.segment;
    i += 1;
    if (i >= endIndex) {
      break;
    }
  }
  return newText;
}
var sliceUntil = segmenter2 ? sliceUntilModern : sliceUntilFallback;

// node_modules/@mui/x-charts/esm/internals/ellipsize.js
var ELLIPSIS = "â€¦";
function doesTextFitInRect(text, config) {
  const {
    width,
    height,
    measureText
  } = config;
  const angle = degToRad(config.angle);
  const textSize = measureText(text);
  const angledWidth = Math.abs(textSize.width * Math.cos(angle)) + Math.abs(textSize.height * Math.sin(angle));
  const angledHeight = Math.abs(textSize.width * Math.sin(angle)) + Math.abs(textSize.height * Math.cos(angle));
  return angledWidth <= width && angledHeight <= height;
}
function ellipsize(text, doesTextFit) {
  if (doesTextFit(text)) {
    return text;
  }
  let shortenedText = text;
  let step = 1;
  let by = 1 / 2;
  const graphemeCount = getGraphemeCount(text);
  let newLength = graphemeCount;
  let lastLength = graphemeCount;
  let longestFittingText = null;
  do {
    lastLength = newLength;
    newLength = Math.floor(graphemeCount * by);
    if (newLength === 0) {
      break;
    }
    shortenedText = sliceUntil(text, newLength).trim();
    const fits = doesTextFit(shortenedText + ELLIPSIS);
    step += 1;
    if (fits) {
      longestFittingText = shortenedText;
      by += 1 / 2 ** step;
    } else {
      by -= 1 / 2 ** step;
    }
  } while (Math.abs(newLength - lastLength) !== 1);
  return longestFittingText ? longestFittingText + ELLIPSIS : "";
}

// node_modules/@mui/x-charts/esm/internals/domUtils.js
function isSsr() {
  return typeof window === "undefined";
}
var stringCache = /* @__PURE__ */ new Map();
var MAX_CACHE_NUM = 2e3;
var SPAN_STYLE = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
};
var STYLE_LIST = ["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height", "top", "left", "fontSize", "padding", "margin", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom"];
var MEASUREMENT_SPAN_ID = "mui_measurement_span";
function autoCompleteStyle(name, value) {
  if (STYLE_LIST.indexOf(name) >= 0 && value === +value) {
    return `${value}px`;
  }
  return value;
}
function camelToMiddleLine(text) {
  const strs = text.split("");
  const formatStrs = strs.reduce((result, entry) => {
    if (entry === entry.toUpperCase()) {
      return [...result, "-", entry.toLowerCase()];
    }
    return [...result, entry];
  }, []);
  return formatStrs.join("");
}
var getStyleString = (style) => Object.keys(style).sort().reduce((result, s) => `${result}${camelToMiddleLine(s)}:${autoCompleteStyle(s, style[s])};`, "");
var domCleanTimeout;
var getStringSize = (text, style = {}) => {
  if (text === void 0 || text === null || isSsr()) {
    return {
      width: 0,
      height: 0
    };
  }
  const str = `${text}`;
  const styleString = getStyleString(style);
  const cacheKey = `${str}-${styleString}`;
  const size = stringCache.get(cacheKey);
  if (size) {
    return size;
  }
  try {
    let measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
    if (measurementSpan === null) {
      measurementSpan = document.createElement("span");
      measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
      measurementSpan.setAttribute("aria-hidden", "true");
      document.body.appendChild(measurementSpan);
    }
    const measurementSpanStyle = _extends({}, SPAN_STYLE, style);
    Object.keys(measurementSpanStyle).map((styleKey) => {
      measurementSpan.style[camelToMiddleLine(styleKey)] = autoCompleteStyle(styleKey, measurementSpanStyle[styleKey]);
      return styleKey;
    });
    measurementSpan.textContent = str;
    const rect = measurementSpan.getBoundingClientRect();
    const result = {
      width: rect.width,
      height: rect.height
    };
    stringCache.set(cacheKey, result);
    if (stringCache.size + 1 > MAX_CACHE_NUM) {
      stringCache.clear();
    }
    if (false) {
      measurementSpan.textContent = "";
    } else {
      if (domCleanTimeout) {
        clearTimeout(domCleanTimeout);
      }
      domCleanTimeout = setTimeout(() => {
        measurementSpan.textContent = "";
      }, 0);
    }
    return result;
  } catch {
    return {
      width: 0,
      height: 0
    };
  }
};

// node_modules/@mui/x-charts/esm/hooks/useTicks.js
var React12 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/isInfinity.js
function isInfinity(v) {
  return typeof v === "number" && !Number.isFinite(v);
}

// node_modules/@mui/x-charts/esm/hooks/useTicks.js
var offsetRatio = {
  start: 0,
  extremities: 0,
  end: 1,
  middle: 0.5
};
function useTicks(options) {
  const {
    scale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement = "extremities",
    tickLabelPlacement: tickLabelPlacementProp,
    direction
  } = options;
  const {
    instance
  } = useChartContext();
  return React12.useMemo(() => {
    if (isBandScale(scale)) {
      const domain2 = scale.domain();
      const tickLabelPlacement2 = tickLabelPlacementProp ?? "middle";
      if (scale.bandwidth() > 0) {
        const filteredDomain2 = typeof tickInterval === "function" && domain2.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain2;
        return [...filteredDomain2.map((value) => ({
          value,
          formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
            location: "tick",
            scale
          })) ?? `${value}`,
          offset: scale(value) - (scale.step() - scale.bandwidth()) / 2 + offsetRatio[tickPlacement] * scale.step(),
          labelOffset: tickLabelPlacement2 === "tick" ? 0 : scale.step() * (offsetRatio[tickLabelPlacement2] - offsetRatio[tickPlacement])
        })), ...tickPlacement === "extremities" ? [{
          formattedValue: void 0,
          offset: scale.range()[1],
          labelOffset: 0
        }] : []];
      }
      const filteredDomain = typeof tickInterval === "function" && domain2.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain2;
      return filteredDomain.map((value) => ({
        value,
        formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
          location: "tick",
          scale
        })) ?? `${value}`,
        offset: scale(value),
        labelOffset: 0
      }));
    }
    const domain = scale.domain();
    if (domain.some(isInfinity)) {
      return [];
    }
    const tickLabelPlacement = tickLabelPlacementProp;
    const ticks = typeof tickInterval === "object" ? tickInterval : scale.ticks(tickNumber);
    const visibleTicks = [];
    for (let i = 0; i < ticks.length; i += 1) {
      const value = ticks[i];
      const offset = scale(value);
      const isInside = direction === "x" ? instance.isXInside(offset) : instance.isYInside(offset);
      if (isInside) {
        visibleTicks.push({
          value,
          formattedValue: (valueFormatter == null ? void 0 : valueFormatter(value, {
            location: "tick",
            scale
          })) ?? scale.tickFormat(tickNumber)(value),
          offset,
          // Allowing the label to be placed in the middle of a continuous scale is weird.
          // But it is useful in some cases, like funnel categories with a linear scale.
          labelOffset: tickLabelPlacement === "middle" ? scale(ticks[i - 1] ?? 0) - (offset + scale(ticks[i - 1] ?? 0)) / 2 : 0
        });
      }
    }
    return visibleTicks;
  }, [scale, tickLabelPlacementProp, tickInterval, tickNumber, tickPlacement, valueFormatter, direction, instance]);
}

// node_modules/@mui/x-charts/esm/ChartsAxis/axisClasses.js
function getAxisUtilityClass(slot) {
  return generateUtilityClass("MuiChartsAxis", slot);
}
var axisClasses = generateUtilityClasses("MuiChartsAxis", ["root", "line", "tickContainer", "tick", "tickLabel", "label", "directionX", "directionY", "top", "bottom", "left", "right", "id"]);

// node_modules/@mui/x-charts/esm/internals/components/AxisSharedComponents.js
var AxisRoot = styled_default("g", {
  name: "MuiChartsAxis",
  slot: "Root"
})(({
  theme
}) => ({
  [`& .${axisClasses.tickLabel}`]: _extends({}, theme.typography.caption, {
    fill: (theme.vars || theme).palette.text.primary
  }),
  [`& .${axisClasses.label}`]: {
    fill: (theme.vars || theme).palette.text.primary
  },
  [`& .${axisClasses.line}`]: {
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges",
    strokeWidth: 1
  },
  [`& .${axisClasses.tick}`]: {
    stroke: (theme.vars || theme).palette.text.primary,
    shapeRendering: "crispEdges"
  }
}));

// node_modules/@mui/x-charts/esm/ChartsText/ChartsText.js
var React13 = __toESM(require_react(), 1);
var import_prop_types10 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/internals/getWordsByLines.js
function getWordsByLines({
  style,
  needsComputation,
  text
}) {
  return text.split("\n").map((subText) => _extends({
    text: subText
  }, needsComputation ? getStringSize(subText, style) : {
    width: 0,
    height: 0
  }));
}

// node_modules/@mui/x-charts/esm/ChartsText/ChartsText.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var _excluded10 = ["x", "y", "style", "text", "ownerState"];
var _excluded22 = ["angle", "textAnchor", "dominantBaseline"];
function ChartsText(props) {
  const {
    x,
    y,
    style: styleProps,
    text
  } = props, textProps = _objectWithoutPropertiesLoose(props, _excluded10);
  const _ref = styleProps ?? {}, {
    angle,
    textAnchor,
    dominantBaseline
  } = _ref, style = _objectWithoutPropertiesLoose(_ref, _excluded22);
  const isHydrated = useIsHydrated();
  const wordsByLines = React13.useMemo(() => getWordsByLines({
    style,
    needsComputation: isHydrated && text.includes("\n"),
    text
  }), [style, text, isHydrated]);
  let startDy;
  switch (dominantBaseline) {
    case "hanging":
    case "text-before-edge":
      startDy = 0;
      break;
    case "central":
      startDy = (wordsByLines.length - 1) / 2 * -wordsByLines[0].height;
      break;
    default:
      startDy = (wordsByLines.length - 1) * -wordsByLines[0].height;
      break;
  }
  return (0, import_jsx_runtime11.jsx)("text", _extends({}, textProps, {
    transform: angle ? `rotate(${angle}, ${x}, ${y})` : void 0,
    x,
    y,
    textAnchor,
    dominantBaseline,
    style,
    children: wordsByLines.map((line, index) => (0, import_jsx_runtime11.jsx)("tspan", {
      x,
      dy: `${index === 0 ? startDy : wordsByLines[0].height}px`,
      dominantBaseline,
      children: line.text
    }, index))
  }));
}
true ? ChartsText.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Height of a text line (in `em`).
   */
  lineHeight: import_prop_types10.default.number,
  /**
   * If `true`, the line width is computed.
   * @default false
   */
  needsComputation: import_prop_types10.default.bool,
  ownerState: import_prop_types10.default.any,
  /**
   * Style applied to text elements.
   */
  style: import_prop_types10.default.object,
  /**
   * Text displayed.
   */
  text: import_prop_types10.default.string.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/internals/geometry.js
var ANGLE_APPROX = 5;
function getMinXTranslation(width, height, angle = 0) {
  if (true) {
    if (angle > 90 && angle < -90) {
      warnOnce([`MUI X Charts: It seems you applied an angle larger than 90Â° or smaller than -90Â° to an axis text.`, `This could cause some text overlapping.`, `If you encounter a use case where it's needed, please open an issue.`]);
    }
  }
  const standardAngle = Math.min(Math.abs(angle) % 180, Math.abs(Math.abs(angle) % 180 - 180) % 180);
  if (standardAngle < ANGLE_APPROX) {
    return width;
  }
  if (standardAngle > 90 - ANGLE_APPROX) {
    return height;
  }
  const radAngle = deg2rad(standardAngle);
  const angleSwich = Math.atan2(height, width);
  if (radAngle < angleSwich) {
    return width / Math.cos(radAngle);
  }
  return height / Math.sin(radAngle);
}

// node_modules/@mui/x-charts/esm/hooks/useMounted.js
var React14 = __toESM(require_react(), 1);
function useMounted(defer = false) {
  const [mountedState, setMountedState] = React14.useState(false);
  useEnhancedEffect_default(() => {
    if (!defer) {
      setMountedState(true);
    }
  }, [defer]);
  React14.useEffect(() => {
    if (defer) {
      setMountedState(true);
    }
  }, [defer]);
  return mountedState;
}

// node_modules/@mui/x-charts/esm/ChartsText/defaultTextPlacement.js
function getDefaultTextAnchor(angle) {
  const adjustedAngle = clampAngle(angle);
  if (adjustedAngle <= 30 || adjustedAngle >= 330) {
    return "middle";
  }
  if (adjustedAngle <= 210 && adjustedAngle >= 150) {
    return "middle";
  }
  if (adjustedAngle <= 180) {
    return "end";
  }
  return "start";
}
function getDefaultBaseline(angle) {
  const adjustedAngle = clampAngle(angle);
  if (adjustedAngle <= 30 || adjustedAngle >= 330) {
    return "hanging";
  }
  if (adjustedAngle <= 210 && adjustedAngle >= 150) {
    return "auto";
  }
  return "central";
}

// node_modules/@mui/x-charts/esm/internals/invertTextAnchor.js
function invertTextAnchor(textAnchor) {
  switch (textAnchor) {
    case "start":
      return "end";
    case "end":
      return "start";
    default:
      return textAnchor;
  }
}

// node_modules/@mui/x-charts/esm/ChartsXAxis/ChartsXAxis.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var _excluded11 = ["scale", "tickNumber", "reverse"];
var useUtilityClasses4 = (ownerState) => {
  const {
    classes,
    position,
    id
  } = ownerState;
  const slots = {
    root: ["root", "directionX", position, `id-${id}`],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return composeClasses(slots, getAxisUtilityClass, classes);
};
var TICK_LABEL_GAP = 3;
var AXIS_LABEL_TICK_LABEL_GAP = 4;
function getVisibleLabels(xTicks, {
  tickLabelStyle: style,
  tickLabelInterval,
  tickLabelMinGap,
  reverse,
  isMounted,
  isXInside
}) {
  const getTickLabelSize = (tick) => {
    if (!isMounted || tick.formattedValue === void 0) {
      return {
        width: 0,
        height: 0
      };
    }
    const tickSizes = getWordsByLines({
      style,
      needsComputation: true,
      text: tick.formattedValue
    });
    return {
      width: Math.max(...tickSizes.map((size) => size.width)),
      height: Math.max(tickSizes.length * tickSizes[0].height)
    };
  };
  if (typeof tickLabelInterval === "function") {
    return new Set(xTicks.filter((item, index) => tickLabelInterval(item.value, index)));
  }
  let previousTextLimit = 0;
  const direction = reverse ? -1 : 1;
  return new Set(xTicks.filter((item, labelIndex) => {
    const {
      offset,
      labelOffset
    } = item;
    const textPosition = offset + labelOffset;
    if (labelIndex > 0 && direction * textPosition < direction * (previousTextLimit + tickLabelMinGap)) {
      return false;
    }
    if (!isXInside(textPosition)) {
      return false;
    }
    const {
      width,
      height
    } = getTickLabelSize(item);
    const distance = getMinXTranslation(width, height, style == null ? void 0 : style.angle);
    const currentTextLimit = textPosition - direction * distance / 2;
    if (labelIndex > 0 && direction * currentTextLimit < direction * (previousTextLimit + tickLabelMinGap)) {
      return false;
    }
    previousTextLimit = textPosition + direction * distance / 2;
    return true;
  }));
}
function shortenLabels(visibleLabels, drawingArea, maxHeight, isRtl, tickLabelStyle) {
  const shortenedLabels = /* @__PURE__ */ new Map();
  const angle = clampAngle((tickLabelStyle == null ? void 0 : tickLabelStyle.angle) ?? 0);
  let leftBoundFactor = 1;
  let rightBoundFactor = 1;
  if ((tickLabelStyle == null ? void 0 : tickLabelStyle.textAnchor) === "start") {
    leftBoundFactor = Infinity;
    rightBoundFactor = 1;
  } else if ((tickLabelStyle == null ? void 0 : tickLabelStyle.textAnchor) === "end") {
    leftBoundFactor = 1;
    rightBoundFactor = Infinity;
  } else {
    leftBoundFactor = 2;
    rightBoundFactor = 2;
  }
  if (angle > 90 && angle < 270) {
    [leftBoundFactor, rightBoundFactor] = [rightBoundFactor, leftBoundFactor];
  }
  if (isRtl) {
    [leftBoundFactor, rightBoundFactor] = [rightBoundFactor, leftBoundFactor];
  }
  for (const item of visibleLabels) {
    if (item.formattedValue) {
      const width = Math.min((item.offset + item.labelOffset) * leftBoundFactor, (drawingArea.left + drawingArea.width + drawingArea.right - item.offset - item.labelOffset) * rightBoundFactor);
      const doesTextFit = (text) => doesTextFitInRect(text, {
        width,
        height: maxHeight,
        angle,
        measureText: (string) => getStringSize(string, tickLabelStyle)
      });
      shortenedLabels.set(item, ellipsize(item.formattedValue.toString(), doesTextFit));
    }
  }
  return shortenedLabels;
}
var XAxisRoot = styled_default(AxisRoot, {
  name: "MuiChartsXAxis",
  slot: "Root"
})({});
var defaultProps = {
  disableLine: false,
  disableTicks: false,
  tickSize: 6,
  tickLabelMinGap: 4
};
function ChartsXAxis(inProps) {
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const _xAxis = xAxis[inProps.axisId ?? xAxisIds[0]], {
    scale: xScale,
    tickNumber,
    reverse
  } = _xAxis, settings = _objectWithoutPropertiesLoose(_xAxis, _excluded11);
  const isMounted = useMounted();
  const themedProps = useThemeProps({
    props: _extends({}, settings, inProps),
    name: "MuiChartsXAxis"
  });
  const defaultizedProps = _extends({}, defaultProps, themedProps);
  const {
    position,
    disableLine,
    disableTicks,
    tickLabelStyle,
    label,
    labelStyle,
    tickSize: tickSizeProp,
    valueFormatter,
    slots,
    slotProps,
    tickInterval,
    tickLabelInterval,
    tickPlacement,
    tickLabelPlacement,
    tickLabelMinGap,
    sx,
    offset,
    height: axisHeight
  } = defaultizedProps;
  const theme = useTheme();
  const isRtl = useRtl();
  const classes = useUtilityClasses4(defaultizedProps);
  const drawingArea = useDrawingArea();
  const {
    left,
    top,
    width,
    height
  } = drawingArea;
  const {
    instance
  } = useChartContext();
  const isHydrated = useIsHydrated();
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const positionSign = position === "bottom" ? 1 : -1;
  const Line = (slots == null ? void 0 : slots.axisLine) ?? "line";
  const Tick = (slots == null ? void 0 : slots.axisTick) ?? "line";
  const TickLabel = (slots == null ? void 0 : slots.axisTickLabel) ?? ChartsText;
  const Label = (slots == null ? void 0 : slots.axisLabel) ?? ChartsText;
  const defaultTextAnchor = getDefaultTextAnchor((position === "bottom" ? 0 : 180) - ((tickLabelStyle == null ? void 0 : tickLabelStyle.angle) ?? 0));
  const defaultDominantBaseline = getDefaultBaseline((position === "bottom" ? 0 : 180) - ((tickLabelStyle == null ? void 0 : tickLabelStyle.angle) ?? 0));
  const axisTickLabelProps = useSlotProps_default({
    elementType: TickLabel,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
    additionalProps: {
      style: _extends({}, theme.typography.caption, {
        fontSize: 12,
        lineHeight: 1.25,
        textAnchor: isRtl ? invertTextAnchor(defaultTextAnchor) : defaultTextAnchor,
        dominantBaseline: defaultDominantBaseline
      }, tickLabelStyle)
    },
    className: classes.tickLabel,
    ownerState: {}
  });
  const xTicks = useTicks({
    scale: xScale,
    tickNumber,
    valueFormatter,
    tickInterval,
    tickPlacement,
    tickLabelPlacement,
    direction: "x"
  });
  const visibleLabels = getVisibleLabels(xTicks, {
    tickLabelStyle: axisTickLabelProps.style,
    tickLabelInterval,
    tickLabelMinGap,
    reverse,
    isMounted,
    isXInside: instance.isXInside
  });
  const axisLabelProps = useSlotProps_default({
    elementType: Label,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
    additionalProps: {
      style: _extends({}, theme.typography.body1, {
        lineHeight: 1,
        fontSize: 14,
        textAnchor: "middle",
        dominantBaseline: position === "bottom" ? "text-after-edge" : "text-before-edge"
      }, labelStyle)
    },
    ownerState: {}
  });
  const domain = xScale.domain();
  const ordinalAxis = isBandScale(xScale);
  if (ordinalAxis && domain.length === 0 || !ordinalAxis && domain.some(isInfinity) || position === "none") {
    return null;
  }
  const labelHeight = label ? getStringSize(label, axisLabelProps.style).height : 0;
  const labelRefPoint = {
    x: left + width / 2,
    y: positionSign * axisHeight
  };
  const tickLabelsMaxHeight = Math.max(0, axisHeight - (label ? labelHeight + AXIS_LABEL_TICK_LABEL_GAP : 0) - tickSize - TICK_LABEL_GAP);
  const tickLabels = isHydrated ? shortenLabels(visibleLabels, drawingArea, tickLabelsMaxHeight, isRtl, axisTickLabelProps.style) : new Map(Array.from(visibleLabels).map((item) => [item, item.formattedValue]));
  return (0, import_jsx_runtime12.jsxs)(XAxisRoot, {
    transform: `translate(0, ${position === "bottom" ? top + height + offset : top - offset})`,
    className: classes.root,
    sx,
    children: [!disableLine && (0, import_jsx_runtime12.jsx)(Line, _extends({
      x1: left,
      x2: left + width,
      className: classes.line
    }, slotProps == null ? void 0 : slotProps.axisLine)), xTicks.map((item, index) => {
      const {
        offset: tickOffset,
        labelOffset
      } = item;
      const xTickLabel = labelOffset ?? 0;
      const yTickLabel = positionSign * (tickSize + TICK_LABEL_GAP);
      const showTick = instance.isXInside(tickOffset);
      const tickLabel = tickLabels.get(item);
      const showTickLabel = visibleLabels.has(item);
      return (0, import_jsx_runtime12.jsxs)("g", {
        transform: `translate(${tickOffset}, 0)`,
        className: classes.tickContainer,
        children: [!disableTicks && showTick && (0, import_jsx_runtime12.jsx)(Tick, _extends({
          y2: positionSign * tickSize,
          className: classes.tick
        }, slotProps == null ? void 0 : slotProps.axisTick)), tickLabel !== void 0 && showTickLabel && (0, import_jsx_runtime12.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel
        }, axisTickLabelProps, {
          text: tickLabel
        }))]
      }, index);
    }), label && (0, import_jsx_runtime12.jsx)("g", {
      className: classes.label,
      children: (0, import_jsx_runtime12.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}
true ? ChartsXAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  axis: import_prop_types11.default.oneOf(["x"]),
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: import_prop_types11.default.oneOfType([import_prop_types11.default.number, import_prop_types11.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types11.default.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: import_prop_types11.default.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: import_prop_types11.default.bool,
  /**
   * The fill color of the axis text.
   * @default 'currentColor'
   */
  fill: import_prop_types11.default.string,
  /**
   * The label of the axis.
   */
  label: import_prop_types11.default.string,
  /**
   * The style applied to the axis label.
   */
  labelStyle: import_prop_types11.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types11.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types11.default.object,
  /**
   * The stroke color of the axis line.
   * @default 'currentColor'
   */
  stroke: import_prop_types11.default.string,
  sx: import_prop_types11.default.oneOfType([import_prop_types11.default.arrayOf(import_prop_types11.default.oneOfType([import_prop_types11.default.func, import_prop_types11.default.object, import_prop_types11.default.bool])), import_prop_types11.default.func, import_prop_types11.default.object]),
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: import_prop_types11.default.oneOfType([import_prop_types11.default.oneOf(["auto"]), import_prop_types11.default.array, import_prop_types11.default.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: import_prop_types11.default.oneOfType([import_prop_types11.default.oneOf(["auto"]), import_prop_types11.default.func]),
  /**
   * The minimum gap in pixels between two tick labels.
   * If two tick labels are closer than this minimum gap, one of them will be hidden.
   * @default 4
   */
  tickLabelMinGap: import_prop_types11.default.number,
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: import_prop_types11.default.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: import_prop_types11.default.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: import_prop_types11.default.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: import_prop_types11.default.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: import_prop_types11.default.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: import_prop_types11.default.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: import_prop_types11.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsYAxis/ChartsYAxis.js
var React16 = __toESM(require_react(), 1);
var import_prop_types12 = __toESM(require_prop_types(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var _excluded12 = ["scale", "tickNumber"];
var useUtilityClasses5 = (ownerState) => {
  const {
    classes,
    position,
    id
  } = ownerState;
  const slots = {
    root: ["root", "directionY", position, `id-${id}`],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return composeClasses(slots, getAxisUtilityClass, classes);
};
var TICK_LABEL_GAP2 = 2;
var AXIS_LABEL_TICK_LABEL_GAP2 = 2;
function shortenLabels2(visibleLabels, drawingArea, maxWidth, isRtl, tickLabelStyle) {
  const shortenedLabels = /* @__PURE__ */ new Map();
  const angle = clampAngle((tickLabelStyle == null ? void 0 : tickLabelStyle.angle) ?? 0);
  let topBoundFactor = 1;
  let bottomBoundFactor = 1;
  if ((tickLabelStyle == null ? void 0 : tickLabelStyle.textAnchor) === "start") {
    topBoundFactor = Infinity;
    bottomBoundFactor = 1;
  } else if ((tickLabelStyle == null ? void 0 : tickLabelStyle.textAnchor) === "end") {
    topBoundFactor = 1;
    bottomBoundFactor = Infinity;
  } else {
    topBoundFactor = 2;
    bottomBoundFactor = 2;
  }
  if (angle > 180) {
    [topBoundFactor, bottomBoundFactor] = [bottomBoundFactor, topBoundFactor];
  }
  if (isRtl) {
    [topBoundFactor, bottomBoundFactor] = [bottomBoundFactor, topBoundFactor];
  }
  for (const item of visibleLabels) {
    if (item.formattedValue) {
      const height = Math.min((item.offset + item.labelOffset) * topBoundFactor, (drawingArea.top + drawingArea.height + drawingArea.bottom - item.offset - item.labelOffset) * bottomBoundFactor);
      const doesTextFit = (text) => doesTextFitInRect(text, {
        width: maxWidth,
        height,
        angle,
        measureText: (string) => getStringSize(string, tickLabelStyle)
      });
      shortenedLabels.set(item, ellipsize(item.formattedValue.toString(), doesTextFit));
    }
  }
  return shortenedLabels;
}
var YAxisRoot = styled_default(AxisRoot, {
  name: "MuiChartsYAxis",
  slot: "Root"
})({});
var defaultProps2 = {
  disableLine: false,
  disableTicks: false,
  tickSize: 6
};
function ChartsYAxis(inProps) {
  const {
    yAxisIds,
    yAxis
  } = useYAxes();
  const _yAxis = yAxis[inProps.axisId ?? yAxisIds[0]], {
    scale: yScale,
    tickNumber
  } = _yAxis, settings = _objectWithoutPropertiesLoose(_yAxis, _excluded12);
  const themedProps = useThemeProps({
    props: _extends({}, settings, inProps),
    name: "MuiChartsYAxis"
  });
  const defaultizedProps = _extends({}, defaultProps2, themedProps);
  const {
    position,
    disableLine,
    disableTicks,
    label,
    labelStyle,
    tickLabelStyle,
    tickSize: tickSizeProp,
    valueFormatter,
    slots,
    slotProps,
    tickPlacement,
    tickLabelPlacement,
    tickInterval,
    tickLabelInterval,
    sx,
    offset,
    width: axisWidth
  } = defaultizedProps;
  const theme = useTheme();
  const isRtl = useRtl();
  const isHydrated = useIsHydrated();
  const classes = useUtilityClasses5(defaultizedProps);
  const {
    instance
  } = useChartContext();
  const drawingArea = useDrawingArea();
  const {
    left,
    top,
    width,
    height
  } = drawingArea;
  const tickSize = disableTicks ? 4 : tickSizeProp;
  const yTicks = useTicks({
    scale: yScale,
    tickNumber,
    valueFormatter,
    tickPlacement,
    tickLabelPlacement,
    tickInterval,
    direction: "y"
  });
  const positionSign = position === "right" ? 1 : -1;
  const tickFontSize = typeof (tickLabelStyle == null ? void 0 : tickLabelStyle.fontSize) === "number" ? tickLabelStyle.fontSize : 12;
  const Line = (slots == null ? void 0 : slots.axisLine) ?? "line";
  const Tick = (slots == null ? void 0 : slots.axisTick) ?? "line";
  const TickLabel = (slots == null ? void 0 : slots.axisTickLabel) ?? ChartsText;
  const Label = (slots == null ? void 0 : slots.axisLabel) ?? ChartsText;
  const defaultTextAnchor = getDefaultTextAnchor((position === "right" ? -90 : 90) - ((tickLabelStyle == null ? void 0 : tickLabelStyle.angle) ?? 0));
  const defaultDominantBaseline = getDefaultBaseline((position === "right" ? -90 : 90) - ((tickLabelStyle == null ? void 0 : tickLabelStyle.angle) ?? 0));
  const axisTickLabelProps = useSlotProps_default({
    elementType: TickLabel,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
    additionalProps: {
      style: _extends({}, theme.typography.caption, {
        fontSize: tickFontSize,
        textAnchor: isRtl ? invertTextAnchor(defaultTextAnchor) : defaultTextAnchor,
        dominantBaseline: defaultDominantBaseline
      }, tickLabelStyle)
    },
    className: classes.tickLabel,
    ownerState: {}
  });
  const axisLabelProps = useSlotProps_default({
    elementType: Label,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
    additionalProps: {
      style: _extends({}, theme.typography.body1, {
        lineHeight: 1,
        fontSize: 14,
        angle: positionSign * 90,
        textAnchor: "middle",
        dominantBaseline: "text-before-edge"
      }, labelStyle)
    },
    ownerState: {}
  });
  const lineSlotProps = useSlotProps_default({
    elementType: Line,
    externalSlotProps: slotProps == null ? void 0 : slotProps.axisLine,
    additionalProps: {
      strokeLinecap: "square"
    },
    ownerState: {}
  });
  const domain = yScale.domain();
  const ordinalAxis = isBandScale(yScale);
  if (ordinalAxis && domain.length === 0 || !ordinalAxis && domain.some(isInfinity) || position === "none") {
    return null;
  }
  const labelRefPoint = {
    x: positionSign * axisWidth,
    y: top + height / 2
  };
  const tickLabelsMaxWidth = Math.max(0, axisWidth - (label ? getStringSize(label, axisLabelProps.style).height + AXIS_LABEL_TICK_LABEL_GAP2 : 0) - tickSize - TICK_LABEL_GAP2);
  const tickLabels = isHydrated ? shortenLabels2(yTicks, drawingArea, tickLabelsMaxWidth, isRtl, axisTickLabelProps.style) : new Map(Array.from(yTicks).map((item) => [item, item.formattedValue]));
  return (0, import_jsx_runtime13.jsxs)(YAxisRoot, {
    transform: `translate(${position === "right" ? left + width + offset : left - offset}, 0)`,
    className: classes.root,
    sx,
    children: [!disableLine && (0, import_jsx_runtime13.jsx)(Line, _extends({
      y1: top,
      y2: top + height,
      className: classes.line
    }, lineSlotProps)), yTicks.map((item, index) => {
      const {
        offset: tickOffset,
        labelOffset,
        value
      } = item;
      const xTickLabel = positionSign * (tickSize + TICK_LABEL_GAP2);
      const yTickLabel = labelOffset;
      const skipLabel = typeof tickLabelInterval === "function" && !(tickLabelInterval == null ? void 0 : tickLabelInterval(value, index));
      const showLabel = instance.isYInside(tickOffset);
      const tickLabel = tickLabels.get(item);
      if (!showLabel) {
        return null;
      }
      return (0, import_jsx_runtime13.jsxs)("g", {
        transform: `translate(0, ${tickOffset})`,
        className: classes.tickContainer,
        children: [!disableTicks && (0, import_jsx_runtime13.jsx)(Tick, _extends({
          x2: positionSign * tickSize,
          className: classes.tick
        }, slotProps == null ? void 0 : slotProps.axisTick)), tickLabel !== void 0 && !skipLabel && (0, import_jsx_runtime13.jsx)(TickLabel, _extends({
          x: xTickLabel,
          y: yTickLabel,
          text: tickLabel
        }, axisTickLabelProps))]
      }, index);
    }), label && isHydrated && (0, import_jsx_runtime13.jsx)("g", {
      className: classes.label,
      children: (0, import_jsx_runtime13.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
        text: label
      }))
    })]
  });
}
true ? ChartsYAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  axis: import_prop_types12.default.oneOf(["y"]),
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: import_prop_types12.default.oneOfType([import_prop_types12.default.number, import_prop_types12.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types12.default.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: import_prop_types12.default.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: import_prop_types12.default.bool,
  /**
   * The fill color of the axis text.
   * @default 'currentColor'
   */
  fill: import_prop_types12.default.string,
  /**
   * The label of the axis.
   */
  label: import_prop_types12.default.string,
  /**
   * The style applied to the axis label.
   */
  labelStyle: import_prop_types12.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types12.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types12.default.object,
  /**
   * The stroke color of the axis line.
   * @default 'currentColor'
   */
  stroke: import_prop_types12.default.string,
  sx: import_prop_types12.default.oneOfType([import_prop_types12.default.arrayOf(import_prop_types12.default.oneOfType([import_prop_types12.default.func, import_prop_types12.default.object, import_prop_types12.default.bool])), import_prop_types12.default.func, import_prop_types12.default.object]),
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: import_prop_types12.default.oneOfType([import_prop_types12.default.oneOf(["auto"]), import_prop_types12.default.array, import_prop_types12.default.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: import_prop_types12.default.oneOfType([import_prop_types12.default.oneOf(["auto"]), import_prop_types12.default.func]),
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: import_prop_types12.default.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: import_prop_types12.default.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: import_prop_types12.default.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: import_prop_types12.default.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: import_prop_types12.default.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: import_prop_types12.default.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: import_prop_types12.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxis/ChartsAxis.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
function ChartsAxis(props) {
  const {
    slots,
    slotProps
  } = props;
  const {
    xAxisIds,
    xAxis
  } = useXAxes();
  const {
    yAxisIds,
    yAxis
  } = useYAxes();
  return (0, import_jsx_runtime14.jsxs)(React17.Fragment, {
    children: [xAxisIds.map((axisId) => {
      if (!xAxis[axisId].position || xAxis[axisId].position === "none") {
        return null;
      }
      return (0, import_jsx_runtime14.jsx)(ChartsXAxis, {
        slots,
        slotProps,
        axisId
      }, axisId);
    }), yAxisIds.map((axisId) => {
      if (!yAxis[axisId].position || yAxis[axisId].position === "none") {
        return null;
      }
      return (0, import_jsx_runtime14.jsx)(ChartsYAxis, {
        slots,
        slotProps,
        axisId
      }, axisId);
    })]
  });
}
true ? ChartsAxis.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types13.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types13.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsAxisHighlight.js
var React20 = __toESM(require_react(), 1);
var import_prop_types14 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/chartsAxisHighlightClasses.js
function getAxisHighlightUtilityClass(slot) {
  return generateUtilityClass("MuiChartsAxisHighlight", slot);
}
var chartsAxisHighlightClasses = generateUtilityClasses("MuiChartsAxisHighlight", ["root"]);

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsYAxisHighlight.js
var React18 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsAxisHighlightPath.js
var ChartsAxisHighlightPath = styled_default("path", {
  name: "MuiChartsAxisHighlight",
  slot: "Root"
})(({
  theme
}) => ({
  pointerEvents: "none",
  variants: [{
    props: {
      axisHighlight: "band"
    },
    style: _extends({
      fill: "white",
      fillOpacity: 0.1
    }, theme.applyStyles("light", {
      fill: "gray"
    }))
  }, {
    props: {
      axisHighlight: "line"
    },
    style: _extends({
      strokeDasharray: "5 2",
      stroke: "#ffffff"
    }, theme.applyStyles("light", {
      stroke: "#000000"
    }))
  }]
}));

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsYAxisHighlight.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
function ChartsYHighlight(props) {
  const {
    type,
    classes
  } = props;
  const {
    left,
    width
  } = useDrawingArea();
  const yScale = useYScale();
  const store = useStore();
  const axisYValue = useSelector(store, selectorChartsInteractionYAxisValue);
  const getYPosition = getValueToPositionMapper(yScale);
  const isBandScaleY = type === "band" && axisYValue !== null && isBandScale(yScale);
  if (true) {
    const isError = isBandScaleY && yScale(axisYValue) === void 0;
    if (isError) {
      console.error([`MUI X Charts: The position value provided for the axis is not valid for the current scale.`, `This probably means something is wrong with the data passed to the chart.`, `The ChartsAxisHighlight component will not be displayed.`].join("\n"));
    }
  }
  return (0, import_jsx_runtime15.jsxs)(React18.Fragment, {
    children: [isBandScaleY && yScale(axisYValue) !== void 0 && (0, import_jsx_runtime15.jsx)(ChartsAxisHighlightPath, {
      d: `M ${left} ${// @ts-expect-error, yScale value is checked in the statement above
      yScale(axisYValue) - (yScale.step() - yScale.bandwidth()) / 2} l 0 ${yScale.step()} l ${width} 0 l 0 ${-yScale.step()} Z`,
      className: classes.root,
      ownerState: {
        axisHighlight: "band"
      }
    }), type === "line" && axisYValue !== null && (0, import_jsx_runtime15.jsx)(ChartsAxisHighlightPath, {
      d: `M ${left} ${getYPosition(axisYValue)} L ${left + width} ${getYPosition(axisYValue)}`,
      className: classes.root,
      ownerState: {
        axisHighlight: "line"
      }
    })]
  });
}

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsXAxisHighlight.js
var React19 = __toESM(require_react(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
function ChartsXHighlight(props) {
  const {
    type,
    classes
  } = props;
  const {
    top,
    height
  } = useDrawingArea();
  const xScale = useXScale();
  const store = useStore();
  const axisXValue = useSelector(store, selectorChartsInteractionXAxisValue);
  const getXPosition = getValueToPositionMapper(xScale);
  const isBandScaleX = type === "band" && axisXValue !== null && isBandScale(xScale);
  if (true) {
    const isError = isBandScaleX && xScale(axisXValue) === void 0;
    if (isError) {
      console.error([`MUI X Charts: The position value provided for the axis is not valid for the current scale.`, `This probably means something is wrong with the data passed to the chart.`, `The ChartsAxisHighlight component will not be displayed.`].join("\n"));
    }
  }
  return (0, import_jsx_runtime16.jsxs)(React19.Fragment, {
    children: [isBandScaleX && xScale(axisXValue) !== void 0 && (0, import_jsx_runtime16.jsx)(
      ChartsAxisHighlightPath,
      {
        d: `M ${xScale(axisXValue) - (xScale.step() - xScale.bandwidth()) / 2} ${top} l ${xScale.step()} 0 l 0 ${height} l ${-xScale.step()} 0 Z`,
        className: classes.root,
        ownerState: {
          axisHighlight: "band"
        }
      }
    ), type === "line" && axisXValue !== null && (0, import_jsx_runtime16.jsx)(ChartsAxisHighlightPath, {
      d: `M ${getXPosition(axisXValue)} ${top} L ${getXPosition(axisXValue)} ${top + height}`,
      className: classes.root,
      ownerState: {
        axisHighlight: "line"
      }
    })]
  });
}

// node_modules/@mui/x-charts/esm/ChartsAxisHighlight/ChartsAxisHighlight.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var useUtilityClasses6 = () => {
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getAxisHighlightUtilityClass);
};
function ChartsAxisHighlight(props) {
  const {
    x: xAxisHighlight,
    y: yAxisHighlight
  } = props;
  const classes = useUtilityClasses6();
  return (0, import_jsx_runtime17.jsxs)(React20.Fragment, {
    children: [xAxisHighlight && (0, import_jsx_runtime17.jsx)(ChartsXHighlight, {
      type: xAxisHighlight,
      classes
    }), yAxisHighlight && (0, import_jsx_runtime17.jsx)(ChartsYHighlight, {
      type: yAxisHighlight,
      classes
    })]
  });
}
true ? ChartsAxisHighlight.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  x: import_prop_types14.default.oneOf(["band", "line", "none"]),
  y: import_prop_types14.default.oneOf(["band", "line", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsClipPath/ChartsClipPath.js
var React21 = __toESM(require_react(), 1);
var import_prop_types15 = __toESM(require_prop_types(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
function ChartsClipPath(props) {
  const {
    id,
    offset: offsetProps
  } = props;
  const {
    left,
    top,
    width,
    height
  } = useDrawingArea();
  const offset = _extends({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, offsetProps);
  return (0, import_jsx_runtime18.jsx)("clipPath", {
    id,
    children: (0, import_jsx_runtime18.jsx)("rect", {
      x: left - offset.left,
      y: top - offset.top,
      width: width + offset.left + offset.right,
      height: height + offset.top + offset.bottom
    })
  });
}
true ? ChartsClipPath.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the clip path.
   */
  id: import_prop_types15.default.string.isRequired,
  /**
   * Offset, in pixels, of the clip path rectangle from the drawing area.
   *
   * A positive value will move the rectangle outside the drawing area.
   */
  offset: import_prop_types15.default.shape({
    bottom: import_prop_types15.default.number,
    left: import_prop_types15.default.number,
    right: import_prop_types15.default.number,
    top: import_prop_types15.default.number
  })
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/LineHighlightPlot.js
var React24 = __toESM(require_react(), 1);
var import_prop_types17 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/LineChart/LineHighlightElement.js
var React23 = __toESM(require_react(), 1);
var import_prop_types16 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-internals/esm/reactMajor/index.js
var React22 = __toESM(require_react());
var reactMajor_default = parseInt(React22.version, 10);

// node_modules/@mui/x-charts/esm/LineChart/LineHighlightElement.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var _excluded13 = ["x", "y", "id", "classes", "color", "shape"];
function getHighlightElementUtilityClass(slot) {
  return generateUtilityClass("MuiHighlightElement", slot);
}
var lineHighlightElementClasses = generateUtilityClasses("MuiHighlightElement", ["root"]);
var useUtilityClasses7 = (ownerState) => {
  const {
    classes,
    id
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`]
  };
  return composeClasses(slots, getHighlightElementUtilityClass, classes);
};
function LineHighlightElement(props) {
  const {
    x,
    y,
    color,
    shape
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded13);
  const classes = useUtilityClasses7(props);
  const Element = shape === "circle" ? "circle" : "path";
  const additionalProps = shape === "circle" ? {
    cx: 0,
    cy: 0,
    r: other.r === void 0 ? 5 : other.r
  } : {
    d: Symbol(symbolsFill[getSymbol(shape)])()
  };
  const transformOrigin = reactMajor_default > 18 ? {
    transformOrigin: `${x} ${y}`
  } : {
    "transform-origin": `${x} ${y}`
  };
  return (0, import_jsx_runtime19.jsx)(Element, _extends({
    pointerEvents: "none",
    className: classes.root,
    transform: `translate(${x} ${y})`,
    fill: color
  }, transformOrigin, additionalProps, other));
}
true ? LineHighlightElement.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types16.default.object,
  id: import_prop_types16.default.oneOfType([import_prop_types16.default.number, import_prop_types16.default.string]).isRequired,
  shape: import_prop_types16.default.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/LineHighlightPlot.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var _excluded14 = ["slots", "slotProps"];
function LineHighlightPlot(props) {
  const {
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded14);
  const seriesData = useLineSeriesContext();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const {
    instance
  } = useChartContext();
  const store = useStore();
  const highlightedIndex = useSelector(store, selectorChartsInteractionXAxisIndex);
  if (highlightedIndex === null) {
    return null;
  }
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    stackingGroups
  } = seriesData;
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  const Element = (slots == null ? void 0 : slots.lineHighlight) ?? LineHighlightElement;
  return (0, import_jsx_runtime20.jsx)("g", _extends({}, other, {
    children: stackingGroups.flatMap(({
      ids: groupIds
    }) => {
      return groupIds.flatMap((seriesId) => {
        const {
          xAxisId = defaultXAxisId,
          yAxisId = defaultYAxisId,
          stackedData,
          data,
          disableHighlight,
          shape = "circle"
        } = series[seriesId];
        if (disableHighlight || data[highlightedIndex] == null) {
          return null;
        }
        const xScale = getValueToPositionMapper(xAxis[xAxisId].scale);
        const yScale = yAxis[yAxisId].scale;
        const xData = xAxis[xAxisId].data;
        if (xData === void 0) {
          throw new Error(`MUI X Charts: ${xAxisId === DEFAULT_X_AXIS_KEY ? "The first `xAxis`" : `The x-axis with id "${xAxisId}"`} should have data property to be able to display a line plot.`);
        }
        const x = xScale(xData[highlightedIndex]);
        const y = yScale(stackedData[highlightedIndex][1]);
        if (!instance.isPointInside(x, y)) {
          return null;
        }
        const colorGetter = getColor_default(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
        return (0, import_jsx_runtime20.jsx)(Element, _extends({
          id: seriesId,
          color: colorGetter(highlightedIndex),
          x,
          y,
          shape
        }, slotProps == null ? void 0 : slotProps.lineHighlight), `${seriesId}`);
      });
    })
  }));
}
true ? LineHighlightPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types17.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types17.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsGrid.js
var React27 = __toESM(require_react(), 1);
var import_prop_types18 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsGrid/chartsGridClasses.js
function getChartsGridUtilityClass(slot) {
  return generateUtilityClass("MuiChartsGrid", slot);
}
var chartsGridClasses = generateUtilityClasses("MuiChartsGrid", ["root", "line", "horizontalLine", "verticalLine"]);

// node_modules/@mui/x-charts/esm/ChartsGrid/styledComponents.js
var GridRoot = styled_default("g", {
  name: "MuiChartsGrid",
  slot: "Root",
  overridesResolver: (props, styles) => [{
    [`&.${chartsGridClasses.verticalLine}`]: styles.verticalLine
  }, {
    [`&.${chartsGridClasses.horizontalLine}`]: styles.horizontalLine
  }, styles.root]
})({});
var GridLine = styled_default("line", {
  name: "MuiChartsGrid",
  slot: "Line"
})(({
  theme
}) => ({
  stroke: (theme.vars || theme).palette.divider,
  shapeRendering: "crispEdges",
  strokeWidth: 1
}));

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsVerticalGrid.js
var React25 = __toESM(require_react(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
function ChartsGridVertical(props) {
  const {
    axis,
    start,
    end,
    classes
  } = props;
  const {
    scale,
    tickNumber,
    tickInterval
  } = axis;
  const xTicks = useTicks({
    scale,
    tickNumber,
    tickInterval,
    direction: "x"
  });
  return (0, import_jsx_runtime21.jsx)(React25.Fragment, {
    children: xTicks.map(({
      value,
      offset
    }) => {
      var _a;
      return (0, import_jsx_runtime21.jsx)(GridLine, {
        y1: start,
        y2: end,
        x1: offset,
        x2: offset,
        className: classes.verticalLine
      }, `vertical-${((_a = value.getTime) == null ? void 0 : _a.call(value)) ?? value}`);
    })
  });
}

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsHorizontalGrid.js
var React26 = __toESM(require_react(), 1);
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
function ChartsGridHorizontal(props) {
  const {
    axis,
    start,
    end,
    classes
  } = props;
  const {
    scale,
    tickNumber,
    tickInterval
  } = axis;
  const yTicks = useTicks({
    scale,
    tickNumber,
    tickInterval,
    direction: "y"
  });
  return (0, import_jsx_runtime22.jsx)(React26.Fragment, {
    children: yTicks.map(({
      value,
      offset
    }) => {
      var _a;
      return (0, import_jsx_runtime22.jsx)(GridLine, {
        y1: offset,
        y2: offset,
        x1: start,
        x2: end,
        className: classes.horizontalLine
      }, `horizontal-${((_a = value.getTime) == null ? void 0 : _a.call(value)) ?? value}`);
    })
  });
}

// node_modules/@mui/x-charts/esm/ChartsGrid/ChartsGrid.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var _excluded15 = ["vertical", "horizontal"];
var useUtilityClasses8 = ({
  classes
}) => {
  const slots = {
    root: ["root"],
    verticalLine: ["line", "verticalLine"],
    horizontalLine: ["line", "horizontalLine"]
  };
  return composeClasses(slots, getChartsGridUtilityClass, classes);
};
function ChartsGrid(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartsGrid"
  });
  const drawingArea = useDrawingArea();
  const {
    vertical,
    horizontal
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded15);
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const classes = useUtilityClasses8(props);
  const horizontalAxis = yAxis[yAxisIds[0]];
  const verticalAxis = xAxis[xAxisIds[0]];
  return (0, import_jsx_runtime23.jsxs)(GridRoot, _extends({}, other, {
    className: classes.root,
    children: [vertical && (0, import_jsx_runtime23.jsx)(ChartsGridVertical, {
      axis: verticalAxis,
      start: drawingArea.top,
      end: drawingArea.height + drawingArea.top,
      classes
    }), horizontal && (0, import_jsx_runtime23.jsx)(ChartsGridHorizontal, {
      axis: horizontalAxis,
      start: drawingArea.left,
      end: drawingArea.width + drawingArea.left,
      classes
    })]
  }));
}
true ? ChartsGrid.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types18.default.object,
  /**
   * Displays horizontal grid.
   */
  horizontal: import_prop_types18.default.bool,
  /**
   * Displays vertical grid.
   */
  vertical: import_prop_types18.default.bool
} : void 0;

// node_modules/@mui/x-charts/esm/LineChart/useLineChartProps.js
var React28 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/LineChart/LineChart.plugins.js
var LINE_CHART_PLUGINS = [useChartZAxis, useChartCartesianAxis, useChartInteraction, useChartHighlight];

// node_modules/@mui/x-charts/esm/LineChart/useLineChartProps.js
var _excluded16 = ["xAxis", "yAxis", "series", "width", "height", "margin", "colors", "dataset", "sx", "onAreaClick", "onLineClick", "onMarkClick", "axisHighlight", "disableLineItemHighlight", "hideLegend", "grid", "children", "slots", "slotProps", "skipAnimation", "loading", "highlightedItem", "onHighlightChange", "className", "showToolbar"];
var useLineChartProps = (props) => {
  var _a, _b, _c, _d, _e;
  const {
    xAxis,
    yAxis,
    series,
    width,
    height,
    margin,
    colors,
    dataset,
    sx,
    onAreaClick,
    onLineClick,
    onMarkClick,
    axisHighlight,
    disableLineItemHighlight,
    grid,
    children,
    slots,
    slotProps,
    skipAnimation,
    loading,
    highlightedItem,
    onHighlightChange,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded16);
  const id = useId();
  const clipPathId = `${id}-clip-path`;
  const seriesWithDefault = React28.useMemo(() => series.map((s) => _extends({
    disableHighlight: !!disableLineItemHighlight,
    type: "line"
  }, s)), [disableLineItemHighlight, series]);
  const chartContainerProps = _extends({}, other, {
    series: seriesWithDefault,
    width,
    height,
    margin,
    colors,
    dataset,
    xAxis: xAxis ?? [{
      id: DEFAULT_X_AXIS_KEY,
      scaleType: "point",
      data: Array.from({
        length: Math.max(...series.map((s) => (s.data ?? dataset ?? []).length))
      }, (_, index) => index)
    }],
    yAxis,
    highlightedItem,
    onHighlightChange,
    disableAxisListener: ((_a = slotProps == null ? void 0 : slotProps.tooltip) == null ? void 0 : _a.trigger) !== "axis" && (axisHighlight == null ? void 0 : axisHighlight.x) === "none" && (axisHighlight == null ? void 0 : axisHighlight.y) === "none",
    className,
    skipAnimation,
    plugins: LINE_CHART_PLUGINS
  });
  const gridProps = {
    vertical: grid == null ? void 0 : grid.vertical,
    horizontal: grid == null ? void 0 : grid.horizontal
  };
  const clipPathGroupProps = {
    clipPath: `url(#${clipPathId})`
  };
  const clipPathProps = {
    id: clipPathId
  };
  const areaPlotProps = {
    slots,
    slotProps,
    onItemClick: onAreaClick
  };
  const linePlotProps = {
    slots,
    slotProps,
    onItemClick: onLineClick
  };
  const markPlotProps = {
    slots,
    slotProps,
    onItemClick: onMarkClick,
    skipAnimation
  };
  const overlayProps = {
    slots,
    slotProps,
    loading
  };
  const chartsAxisProps = {
    slots,
    slotProps
  };
  const axisHighlightProps = _extends({
    x: "line"
  }, axisHighlight);
  const lineHighlightPlotProps = {
    slots,
    slotProps
  };
  const legendProps = {
    slots,
    slotProps
  };
  const chartsWrapperProps = {
    sx,
    legendPosition: (_c = (_b = props.slotProps) == null ? void 0 : _b.legend) == null ? void 0 : _c.position,
    legendDirection: (_e = (_d = props.slotProps) == null ? void 0 : _d.legend) == null ? void 0 : _e.direction
  };
  return {
    chartsWrapperProps,
    chartContainerProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    areaPlotProps,
    linePlotProps,
    markPlotProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    lineHighlightPlotProps,
    legendProps,
    children
  };
};

// node_modules/@mui/x-charts/esm/LineChart/LineChart.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var LineChart = React29.forwardRef(function LineChart2(inProps, ref) {
  var _a, _b, _c, _d;
  const props = useThemeProps({
    props: inProps,
    name: "MuiLineChart"
  });
  const {
    chartsWrapperProps,
    chartContainerProps,
    gridProps,
    clipPathProps,
    clipPathGroupProps,
    areaPlotProps,
    linePlotProps,
    markPlotProps,
    overlayProps,
    chartsAxisProps,
    axisHighlightProps,
    lineHighlightPlotProps,
    legendProps,
    children
  } = useLineChartProps(props);
  const {
    chartDataProviderProps,
    chartsSurfaceProps
  } = useChartContainerProps(chartContainerProps, ref);
  const Tooltip = ((_a = props.slots) == null ? void 0 : _a.tooltip) ?? ChartsTooltip;
  const Toolbar = (_b = props.slots) == null ? void 0 : _b.toolbar;
  return (0, import_jsx_runtime24.jsx)(ChartDataProvider, _extends({}, chartDataProviderProps, {
    children: (0, import_jsx_runtime24.jsxs)(ChartsWrapper, _extends({}, chartsWrapperProps, {
      children: [props.showToolbar && Toolbar ? (0, import_jsx_runtime24.jsx)(Toolbar, _extends({}, (_c = props.slotProps) == null ? void 0 : _c.toolbar)) : null, !props.hideLegend && (0, import_jsx_runtime24.jsx)(ChartsLegend, _extends({}, legendProps)), (0, import_jsx_runtime24.jsxs)(ChartsSurface, _extends({}, chartsSurfaceProps, {
        children: [(0, import_jsx_runtime24.jsx)(ChartsGrid, _extends({}, gridProps)), (0, import_jsx_runtime24.jsxs)("g", _extends({}, clipPathGroupProps, {
          children: [(0, import_jsx_runtime24.jsx)(AreaPlot, _extends({}, areaPlotProps)), (0, import_jsx_runtime24.jsx)(LinePlot, _extends({}, linePlotProps)), (0, import_jsx_runtime24.jsx)(ChartsOverlay, _extends({}, overlayProps)), (0, import_jsx_runtime24.jsx)(ChartsAxisHighlight, _extends({}, axisHighlightProps))]
        })), (0, import_jsx_runtime24.jsx)(ChartsAxis, _extends({}, chartsAxisProps)), (0, import_jsx_runtime24.jsx)("g", {
          "data-drawing-container": true,
          children: (0, import_jsx_runtime24.jsx)(MarkPlot, _extends({}, markPlotProps))
        }), (0, import_jsx_runtime24.jsx)(LineHighlightPlot, _extends({}, lineHighlightPlotProps)), (0, import_jsx_runtime24.jsx)(ChartsClipPath, _extends({}, clipPathProps)), children]
      })), !props.loading && (0, import_jsx_runtime24.jsx)(Tooltip, _extends({}, (_d = props.slotProps) == null ? void 0 : _d.tooltip))]
    }))
  }));
});
if (true) LineChart.displayName = "LineChart";
true ? LineChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types19.default.shape({
    current: import_prop_types19.default.object
  }),
  /**
   * The configuration of axes highlight.
   * @see See {@link https://mui.com/x/react-charts/highlighting/ highlighting docs} for more details.
   * @default { x: 'line' }
   */
  axisHighlight: import_prop_types19.default.shape({
    x: import_prop_types19.default.oneOf(["band", "line", "none"]),
    y: import_prop_types19.default.oneOf(["band", "line", "none"])
  }),
  children: import_prop_types19.default.node,
  className: import_prop_types19.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string), import_prop_types19.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types19.default.arrayOf(import_prop_types19.default.object),
  desc: import_prop_types19.default.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: import_prop_types19.default.bool,
  /**
   * If `true`, render the line highlight item.
   */
  disableLineItemHighlight: import_prop_types19.default.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: import_prop_types19.default.shape({
    horizontal: import_prop_types19.default.bool,
    vertical: import_prop_types19.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types19.default.number,
  /**
   * If `true`, the legend is not rendered.
   */
  hideLegend: import_prop_types19.default.bool,
  /**
   * The highlighted item.
   * Used when the highlight is controlled.
   */
  highlightedItem: import_prop_types19.default.shape({
    dataIndex: import_prop_types19.default.number,
    seriesId: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]).isRequired
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types19.default.string,
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types19.default.bool,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types19.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.shape({
    bottom: import_prop_types19.default.number,
    left: import_prop_types19.default.number,
    right: import_prop_types19.default.number,
    top: import_prop_types19.default.number
  })]),
  /**
   * Callback fired when an area element is clicked.
   */
  onAreaClick: import_prop_types19.default.func,
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | ChartsAxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: import_prop_types19.default.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types19.default.func,
  /**
   * Callback fired when a line element is clicked.
   */
  onLineClick: import_prop_types19.default.func,
  /**
   * Callback fired when a mark element is clicked.
   */
  onMarkClick: import_prop_types19.default.func,
  /**
   * The series to display in the line chart.
   * An array of [[LineSeriesType]] objects.
   */
  series: import_prop_types19.default.arrayOf(import_prop_types19.default.object).isRequired,
  /**
   * If true, shows the default chart toolbar.
   * @default false
   */
  showToolbar: import_prop_types19.default.bool,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types19.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types19.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types19.default.object,
  sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
  theme: import_prop_types19.default.oneOf(["dark", "light"]),
  title: import_prop_types19.default.string,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types19.default.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["x"]),
    barGapRatio: import_prop_types19.default.number,
    categoryGapRatio: import_prop_types19.default.number,
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      type: import_prop_types19.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types19.default.string,
      values: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number, import_prop_types19.default.string]).isRequired)
    }), import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    height: import_prop_types19.default.number,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["band"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelMinGap: import_prop_types19.default.number,
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["x"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      type: import_prop_types19.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types19.default.string,
      values: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number, import_prop_types19.default.string]).isRequired)
    }), import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    height: import_prop_types19.default.number,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["point"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelMinGap: import_prop_types19.default.number,
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["x"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    height: import_prop_types19.default.number,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["log"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelMinGap: import_prop_types19.default.number,
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["x"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    height: import_prop_types19.default.number,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["pow"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelMinGap: import_prop_types19.default.number,
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["x"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    height: import_prop_types19.default.number,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["sqrt"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelMinGap: import_prop_types19.default.number,
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["x"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    height: import_prop_types19.default.number,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["time"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelMinGap: import_prop_types19.default.number,
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["x"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    height: import_prop_types19.default.number,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["utc"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelMinGap: import_prop_types19.default.number,
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["x"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    height: import_prop_types19.default.number,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["bottom", "none", "top"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["linear"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelMinGap: import_prop_types19.default.number,
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func
  })]).isRequired),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["y"]),
    barGapRatio: import_prop_types19.default.number,
    categoryGapRatio: import_prop_types19.default.number,
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      type: import_prop_types19.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types19.default.string,
      values: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number, import_prop_types19.default.string]).isRequired)
    }), import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["band"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func,
    width: import_prop_types19.default.number
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["y"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      type: import_prop_types19.default.oneOf(["ordinal"]).isRequired,
      unknownColor: import_prop_types19.default.string,
      values: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number, import_prop_types19.default.string]).isRequired)
    }), import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["point"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func,
    width: import_prop_types19.default.number
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["y"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["log"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func,
    width: import_prop_types19.default.number
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["y"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["pow"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func,
    width: import_prop_types19.default.number
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["y"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["sqrt"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func,
    width: import_prop_types19.default.number
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["y"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["time"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func,
    width: import_prop_types19.default.number
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["y"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["utc"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func,
    width: import_prop_types19.default.number
  }), import_prop_types19.default.shape({
    axis: import_prop_types19.default.oneOf(["y"]),
    classes: import_prop_types19.default.object,
    colorMap: import_prop_types19.default.oneOfType([import_prop_types19.default.shape({
      color: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.string.isRequired), import_prop_types19.default.func]).isRequired,
      max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
      type: import_prop_types19.default.oneOf(["continuous"]).isRequired
    }), import_prop_types19.default.shape({
      colors: import_prop_types19.default.arrayOf(import_prop_types19.default.string).isRequired,
      thresholds: import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]).isRequired).isRequired,
      type: import_prop_types19.default.oneOf(["piecewise"]).isRequired
    })]),
    data: import_prop_types19.default.array,
    dataKey: import_prop_types19.default.string,
    disableLine: import_prop_types19.default.bool,
    disableTicks: import_prop_types19.default.bool,
    domainLimit: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["nice", "strict"]), import_prop_types19.default.func]),
    fill: import_prop_types19.default.string,
    hideTooltip: import_prop_types19.default.bool,
    id: import_prop_types19.default.oneOfType([import_prop_types19.default.number, import_prop_types19.default.string]),
    ignoreTooltip: import_prop_types19.default.bool,
    label: import_prop_types19.default.string,
    labelStyle: import_prop_types19.default.object,
    max: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    min: import_prop_types19.default.oneOfType([import_prop_types19.default.instanceOf(Date), import_prop_types19.default.number]),
    offset: import_prop_types19.default.number,
    position: import_prop_types19.default.oneOf(["left", "none", "right"]),
    reverse: import_prop_types19.default.bool,
    scaleType: import_prop_types19.default.oneOf(["linear"]),
    slotProps: import_prop_types19.default.object,
    slots: import_prop_types19.default.object,
    stroke: import_prop_types19.default.string,
    sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object]),
    tickInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.array, import_prop_types19.default.func]),
    tickLabelInterval: import_prop_types19.default.oneOfType([import_prop_types19.default.oneOf(["auto"]), import_prop_types19.default.func]),
    tickLabelPlacement: import_prop_types19.default.oneOf(["middle", "tick"]),
    tickLabelStyle: import_prop_types19.default.object,
    tickMaxStep: import_prop_types19.default.number,
    tickMinStep: import_prop_types19.default.number,
    tickNumber: import_prop_types19.default.number,
    tickPlacement: import_prop_types19.default.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: import_prop_types19.default.number,
    valueFormatter: import_prop_types19.default.func,
    width: import_prop_types19.default.number
  })]).isRequired)
} : void 0;
export {
  AnimatedArea,
  AnimatedLine,
  AreaElement,
  AreaPlot,
  LineChart,
  LineElement,
  LineHighlightElement,
  LineHighlightPlot,
  LinePlot,
  MarkElement,
  MarkPlot,
  areaElementClasses,
  getAreaElementUtilityClass,
  getHighlightElementUtilityClass,
  getLineElementUtilityClass,
  getMarkElementUtilityClass,
  lineElementClasses,
  lineHighlightElementClasses,
  markElementClasses
};
//# sourceMappingURL=@mui_x-charts_LineChart.js.map
